#!/bin/bash

# Batch Pokémon Data Retrieval Script
# Objective: Automate the retrieval of data for multiple Pokémon 
# and store it in separate files with proper error handling and rate limiting

# Set up error handling
set -e
trap 'echo "Error occurred on line $LINENO. Exit code: $?" >> batch_errors.txt; exit 1' ERR

# Configuration
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
DATA_DIR="pokemon_data"
ERROR_FILE="batch_errors.txt"
REQUEST_DELAY=2  # Delay between requests to handle rate limiting
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log messages with timestamp
log_message() {
    echo "[$TIMESTAMP] $1" >> batch_processing.log
}

# Function to log errors
log_error() {
    local error_msg="$1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') ERROR: $error_msg" >> "$ERROR_FILE"
    echo -e "${RED}ERROR: $error_msg${NC}" >&2
}

# Function to print success message
print_success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info message
print_info() {
    echo -e "${BLUE}$1${NC}"
}

# Function to print warning message
print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Function to check dependencies
check_dependencies() {
    local missing_deps=()
    
    for cmd in curl jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install the missing commands:"
        echo "  Ubuntu/Debian: sudo apt install ${missing_deps[*]}"
        echo "  CentOS/RHEL: sudo yum install ${missing_deps[*]}"
        echo "  macOS: brew install ${missing_deps[*]}"
        exit 1
    fi
}

# Function to create data directory
setup_data_directory() {
    if [ ! -d "$DATA_DIR" ]; then
        mkdir -p "$DATA_DIR"
        log_message "Created data directory: $DATA_DIR"
        print_info "Created data directory: $DATA_DIR"
    fi
}

# Function to fetch Pokémon data
fetch_pokemon_data() {
    local pokemon_name="$1"
    local api_url="${API_BASE_URL}/${pokemon_name}"
    local output_file="${DATA_DIR}/${pokemon_name}.json"
    
    print_info "Fetching data for ${pokemon_name}..."
    log_message "Starting API request for: $pokemon_name"
    
    # Make the API request with comprehensive error handling
    if curl -s --fail --connect-timeout 30 --max-time 60 "$api_url" -o "$output_file"; then
        # Verify the JSON is valid
        if jq empty "$output_file" 2>/dev/null; then
            print_success "Saved data to ${DATA_DIR}/${pokemon_name}.json ✅"
            log_message "Successfully saved data for $pokemon_name"
            return 0
        else
            log_error "Invalid JSON received for $pokemon_name"
            rm -f "$output_file"
            return 1
        fi
    else
        local curl_exit_code=$?
        case $curl_exit_code in
            6)
                log_error "Could not resolve host for $pokemon_name. Check internet connection."
                ;;
            7)
                log_error "Failed to connect to API server for $pokemon_name."
                ;;
            22)
                log_error "HTTP error for $pokemon_name. Pokemon might not exist."
                ;;
            28)
                log_error "Request timeout for $pokemon_name. Server took too long to respond."
                ;;
            *)
                log_error "API request failed for $pokemon_name with exit code: $curl_exit_code"
                ;;
        esac
        return 1
    fi
}

# Function to process batch with rate limiting
process_batch() {
    local total_pokemon=${#POKEMON_LIST[@]}
    local successful=0
    local failed=0
    
    print_info "Starting batch processing of $total_pokemon Pokémon..."
    log_message "Batch processing started with $total_pokemon Pokémon"
    
    for i in "${!POKEMON_LIST[@]}"; do
        local pokemon="${POKEMON_LIST[i]}"
        local progress=$((i + 1))
        
        print_info "[$progress/$total_pokemon] Processing: $pokemon"
        
        if fetch_pokemon_data "$pokemon"; then
            ((successful++))
        else
            ((failed++))
            print_warning "Failed to fetch data for $pokemon"
        fi
        
        # Add delay between requests (except for the last one)
        if [ $progress -lt $total_pokemon ]; then
            log_message "Waiting ${REQUEST_DELAY}s before next request (rate limiting)"
            sleep $REQUEST_DELAY
        fi
    done
    
    # Print summary
    echo ""
    print_info "=== Batch Processing Summary ==="
    print_success "Successful: $successful/$total_pokemon"
    if [ $failed -gt 0 ]; then
        print_warning "Failed: $failed/$total_pokemon"
    fi
    
    log_message "Batch processing completed. Success: $successful, Failed: $failed"
}

# Function to validate downloaded files
validate_files() {
    print_info "Validating downloaded files..."
    local validation_errors=0
    
    for pokemon in "${POKEMON_LIST[@]}"; do
        local file_path="${DATA_DIR}/${pokemon}.json"
        
        if [ -f "$file_path" ]; then
            # Check file size
            local file_size=$(stat -f%z "$file_path" 2>/dev/null || stat -c%s "$file_path" 2>/dev/null)
            if [ "$file_size" -lt 100 ]; then
                print_warning "Warning: ${pokemon}.json seems too small ($file_size bytes)"
                ((validation_errors++))
                continue
            fi
            
            # Validate JSON structure and check for required fields
            if jq -e '.name and .id and .types and .height and .weight' "$file_path" >/dev/null 2>&1; then
                print_success "✅ ${pokemon}.json - Valid"
            else
                print_warning "⚠️  ${pokemon}.json - Missing required fields"
                ((validation_errors++))
            fi
        else
            print_warning "❌ ${pokemon}.json - File not found"
            ((validation_errors++))
        fi
    done
    
    if [ $validation_errors -eq 0 ]; then
        print_success "All files validated successfully!"
    else
        print_warning "$validation_errors validation issues found"
    fi
}

# Function to display file statistics
show_statistics() {
    print_info "=== File Statistics ==="
    
    for pokemon in "${POKEMON_LIST[@]}"; do
        local file_path="${DATA_DIR}/${pokemon}.json"
        
        if [ -f "$file_path" ]; then
            local file_size=$(stat -f%z "$file_path" 2>/dev/null || stat -c%s "$file_path" 2>/dev/null)
            local formatted_size=$(numfmt --to=iec-i --suffix=B "$file_size" 2>/dev/null || echo "${file_size}B")
            
            # Extract basic info using jq
            local pokemon_id=$(jq -r '.id' "$file_path" 2>/dev/null || echo "N/A")
            local pokemon_height=$(jq -r '.height' "$file_path" 2>/dev/null || echo "N/A")
            local pokemon_weight=$(jq -r '.weight' "$file_path" 2>/dev/null || echo "N/A")
            
            printf "%-15s | ID: %-3s | Size: %-8s | H: %-3s | W: %-3s\n" \
                   "$pokemon" "$pokemon_id" "$formatted_size" "$pokemon_height" "$pokemon_weight"
        else
            printf "%-15s | ❌ File not found\n" "$pokemon"
        fi
    done
}

# Function to clean up failed downloads
cleanup_failed() {
    print_info "Cleaning up any incomplete files..."
    
    for pokemon in "${POKEMON_LIST[@]}"; do
        local file_path="${DATA_DIR}/${pokemon}.json"
        
        if [ -f "$file_path" ]; then
            # Check if file is valid JSON and has minimum required content
            if ! jq -e '.name' "$file_path" >/dev/null 2>&1; then
                print_warning "Removing invalid file: $file_path"
                rm -f "$file_path"
            fi
        fi
    done
}

# Function to display usage
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Batch Pokémon data retrieval script"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help        Show this help message"
    echo "  -d, --delay SEC   Set delay between requests (default: 2 seconds)"
    echo "  -o, --output DIR  Set output directory (default: pokemon_data)"
    echo "  -v, --validate    Only validate existing files"
    echo "  -s, --stats       Show file statistics"
    echo "  -c, --cleanup     Clean up failed downloads"
    echo ""
    echo "Examples:"
    echo "  $0                    # Run with default settings"
    echo "  $0 --delay 5          # Use 5-second delay between requests"
    echo "  $0 --output my_data   # Save to 'my_data' directory"
    echo "  $0 --validate         # Only validate existing files"
}

# Main execution function
main() {
    local validate_only=false
    local stats_only=false
    local cleanup_only=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -d|--delay)
                REQUEST_DELAY="$2"
                if ! [[ "$REQUEST_DELAY" =~ ^[0-9]+$ ]]; then
                    echo "Error: Delay must be a positive integer" >&2
                    exit 1
                fi
                shift 2
                ;;
            -o|--output)
                DATA_DIR="$2"
                shift 2
                ;;
            -v|--validate)
                validate_only=true
                shift
                ;;
            -s|--stats)
                stats_only=true
                shift
                ;;
            -c|--cleanup)
                cleanup_only=true
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Initialize error log
    > "$ERROR_FILE"
    
    # Check dependencies
    check_dependencies
    
    # Setup data directory
    setup_data_directory
    
    # Execute based on options
    if [ "$cleanup_only" = true ]; then
        cleanup_failed
    elif [ "$validate_only" = true ]; then
        validate_files
    elif [ "$stats_only" = true ]; then
        show_statistics
    else
        # Run full batch processing
        process_batch
        echo ""
        validate_files
        echo ""
        show_statistics
    fi
    
    # Show error summary if there were any errors
    if [ -s "$ERROR_FILE" ]; then
        echo ""
        print_warning "Some errors occurred during processing. Check $ERROR_FILE for details."
    fi
}

# Execute main function with all arguments
main "$@"
